#!/usr/bin/env python3
"""Apply either fitted params (JSON) or a baked 3D LUT to an input image."""

import argparse
import json
import sys
from pathlib import Path
from typing import Optional

import imageio.v3 as iio
import numpy as np
import torch

# Ensure project root (one level up from scripts/) is importable
REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from scripts.fivek_tif_to_xmp import (
    edit_layer_realunits,
    prophoto_to_srgb_preview,
    read_raw_linear_prophoto,
)


def load_params(path: Path) -> dict:
    data = json.loads(path.read_text())
    if "params_denorm" in data:
        return data["params_denorm"]
    return data


def ensure_long_side(value: Optional[int]) -> int:
    if value is None or value <= 0:
        raise ValueError("--long_side must be a positive integer")
    return value


def apply_params(raw_path: Path, params_path: Path, output_path: Path, long_side: int) -> None:
    params = load_params(params_path)
    raw_tensor = read_raw_linear_prophoto(raw_path, long_side=long_side)
    edited_pp = edit_layer_realunits(raw_tensor, params)
    preview = prophoto_to_srgb_preview(edited_pp)
    write_preview(preview, output_path)


def load_cube_lut(path: Path) -> np.ndarray:
    size: Optional[int] = None
    data: list[list[float]] = []
    domain_min = None
    domain_max = None

    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            tokens = line.split()
            key = tokens[0].upper()
            if key in {"TITLE"}:
                continue
            if key == "DOMAIN_MIN":
                domain_min = list(map(float, tokens[1:]))
                continue
            if key == "DOMAIN_MAX":
                domain_max = list(map(float, tokens[1:]))
                continue
            if key == "LUT_3D_SIZE":
                size = int(tokens[1]) if len(tokens) > 1 else int(tokens[0].split()[1])
                continue
            # Data row: three floats
            if len(tokens) >= 3:
                data.append([float(tokens[0]), float(tokens[1]), float(tokens[2])])

    if size is None:
        raise ValueError(f"Missing LUT_3D_SIZE in {path}")
    expected = size ** 3
    if len(data) != expected:
        raise ValueError(f"Expected {expected} rows in LUT but found {len(data)}")
    if domain_min and any(abs(v) > 1e-6 for v in domain_min):
        raise ValueError("Only DOMAIN_MIN 0 0 0 is supported")
    if domain_max and any(abs(v - 1.0) > 1e-6 for v in domain_max):
        raise ValueError("Only DOMAIN_MAX 1 1 1 is supported")

    lut = np.asarray(data, dtype=np.float32).reshape(size, size, size, 3)
    return lut


def apply_cube_lut(image: np.ndarray, lut: np.ndarray) -> np.ndarray:
    """Apply trilinear interpolation of a 3D LUT to a linear ProPhoto image."""

    size = lut.shape[0]
    coords = np.clip(image, 0.0, 1.0) * (size - 1)

    idx0 = np.floor(coords).astype(np.int32)
    idx1 = np.clip(idx0 + 1, 0, size - 1)
    frac = coords - idx0

    r0, g0, b0 = idx0[..., 0], idx0[..., 1], idx0[..., 2]
    r1, g1, b1 = idx1[..., 0], idx1[..., 1], idx1[..., 2]
    fr, fg, fb = frac[..., 0], frac[..., 1], frac[..., 2]

    c000 = lut[r0, g0, b0]
    c100 = lut[r1, g0, b0]
    c010 = lut[r0, g1, b0]
    c110 = lut[r1, g1, b0]
    c001 = lut[r0, g0, b1]
    c101 = lut[r1, g0, b1]
    c011 = lut[r0, g1, b1]
    c111 = lut[r1, g1, b1]

    w000 = (1 - fr) * (1 - fg) * (1 - fb)
    w100 = fr * (1 - fg) * (1 - fb)
    w010 = (1 - fr) * fg * (1 - fb)
    w110 = fr * fg * (1 - fb)
    w001 = (1 - fr) * (1 - fg) * fb
    w101 = fr * (1 - fg) * fb
    w011 = (1 - fr) * fg * fb
    w111 = fr * fg * fb

    out = (
        c000 * w000[..., None]
        + c100 * w100[..., None]
        + c010 * w010[..., None]
        + c110 * w110[..., None]
        + c001 * w001[..., None]
        + c101 * w101[..., None]
        + c011 * w011[..., None]
        + c111 * w111[..., None]
    )
    return np.clip(out, 0.0, 1.0).astype(np.float32)


def apply_lut(raw_path: Path, lut_path: Path, output_path: Path, long_side: int) -> None:
    raw_tensor = read_raw_linear_prophoto(raw_path, long_side=long_side)
    img = raw_tensor.squeeze(0).permute(1, 2, 0).cpu().numpy()
    lut = load_cube_lut(lut_path)
    mapped = apply_cube_lut(img, lut)
    preview = prophoto_to_srgb_preview(torch.from_numpy(mapped).permute(2, 0, 1).unsqueeze(0))
    write_preview(preview, output_path)


def write_preview(preview01: np.ndarray, output_path: Path) -> None:
    """Write sRGB preview as PNG (8-bit) or TIFF (16-bit) based on extension."""

    output_path.parent.mkdir(parents=True, exist_ok=True)
    ext = output_path.suffix.lower()
    preview01 = np.clip(preview01, 0.0, 1.0)
    if ext in {".tif", ".tiff"}:
        arr16 = (preview01 * 65535.0 + 0.5).astype(np.uint16)
        iio.imwrite(output_path, arr16)
    else:
        arr8 = (preview01 * 255.0 + 0.5).astype(np.uint8)
        iio.imwrite(output_path, arr8)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("raw", type=Path, help="Input DNG RAW file")
    parser.add_argument("artifact", type=Path,
                        help="JSON params file (default) or .cube LUT when --use_lut is set")
    parser.add_argument("--long_side", type=int, default=1024,
                        help="Resize long edge before applying (use smaller for speed; default 1024)")
    parser.add_argument("--out", type=Path,
                        help="Output image path (default: <raw_stem>_edit.png next to artifact)")
    parser.add_argument("--use_lut", action="store_true",
                        help="Treat artifact as a .cube LUT instead of JSON params")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    long_side = ensure_long_side(args.long_side)
    raw_path = args.raw
    artifact_path = args.artifact
    out_path = args.out
    if out_path is None:
        suffix = "lut" if args.use_lut else "edit"
        out_path = artifact_path.parent / f"{raw_path.stem}_{suffix}.png"

    if args.use_lut:
        apply_lut(raw_path, artifact_path, out_path, long_side)
    else:
        apply_params(raw_path, artifact_path, out_path, long_side)
    print(f"[ok] wrote preview to {out_path}")


if __name__ == "__main__":
    main()
